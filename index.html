<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Character Maps - Audiobook Player</title>
    <style>
        /* Base reset and modern mobile-friendly styling */
        body {
          margin: 0;
          padding: 0;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
          color: #333;
          background-color: #f5f5f7;
          line-height: 1.5;
          -webkit-font-smoothing: antialiased;
        }
        * {
          box-sizing: border-box;
        }
        h1, h2, h3 { 
          margin: 0 0 0.5em 0; 
          font-weight: 600;
        }
        p { margin: 0 0 1em; }

        /* Mobile-friendly header */
        .app-header {
          background: #1a1a1a;
          color: white;
          padding: 16px;
          text-align: center;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
          position: relative;
        }
        
        .app-title {
          font-size: 18px;
          font-weight: 600;
        }
        
        .app-subtitle {
          font-size: 14px;
          color: #aaa;
          margin-top: 4px;
        }
        
        .book-selector {
          width: 100%;
          max-width: 300px;
          padding: 16px 20px;
          font-size: 18px;
          font-weight: 600;
          color: #333;
          background: white;
          border: 2px solid #ddd;
          border-radius: 12px;
          outline: none;
          -webkit-appearance: none;
          -moz-appearance: none;
          appearance: none;
          text-align: center;
          text-align-last: center;
          cursor: pointer;
          margin: 0 auto;
          display: block;
        }
        
        .book-selector:focus {
          outline: none;
          border-color: #34C759;
          box-shadow: 0 0 0 3px rgba(52, 199, 89, 0.2);
        }
        
        .book-selector option {
          background: white;
          color: #333;
        }

        /* Main container - mobile first */
        .app-container {
          max-width: 100%;
          margin: 0 auto;
          padding: 16px;
        }

        /* Card styling for sections */
        .card {
          background: white;
          border-radius: 16px;
          padding: 20px;
          margin-bottom: 16px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .card-title {
          font-size: 16px;
          color: #666;
          margin-bottom: 16px;
          padding-bottom: 8px;
          border-bottom: 1px solid #eee;
        }

        /* Current info display */
        .current-info {
          text-align: center;
          margin-bottom: 16px;
        }
        
        .book-title {
          font-size: 18px;
          font-weight: 600;
          color: #333;
          margin-bottom: 4px;
        }
        
        .book-details {
          font-size: 14px;
          color: #666;
          margin-bottom: 8px;
        }
        
        .speaker-info {
          font-size: 16px;
          padding: 8px 16px;
          background-color: #f8f9fa;
          display: inline-block;
          border-radius: 20px;
          color: #444;
          font-weight: 500;
        }
        
        .content-type-info {
          margin-top: 8px;
          font-size: 14px;
          color: #666;
          text-align: center;
        }

        /* Player controls */
        .player-controls {
          text-align: center;
        }
        
        .time-display {
          font-size: 12px;
          color: #888;
          margin-bottom: 12px;
          font-weight: 500;
        }
        
        .progress-container {
          background: #e0e0e0;
          border-radius: 3px;
          height: 4px;
          margin: 16px 0;
          cursor: pointer;
        }
        .progress-bar {
          background: #34C759;
          height: 100%;
          width: 0%;
          border-radius: 3px;
          transition: width 0.1s linear;
        }
        
        .control-buttons {
          display: flex;
          justify-content: center;
          gap: 20px;
          margin: 20px 0;
        }
        
        .control-btn {
          width: 50px;
          height: 50px;
          border-radius: 50%;
          border: none;
          background: #f0f0f0;
          color: #333;
          font-size: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          box-shadow: 0 2px 6px rgba(0,0,0,0.1);
          transition: all 0.2s ease;
        }
        
        .control-btn:active {
          transform: scale(0.95);
          background: #e0e0e0;
        }
        
        .control-btn.primary {
          background: #34C759;
          color: white;
        }
        
        .control-btn.primary:active {
          background: #21A947;
        }

        /* Volume and speed controls */
        .volume-control, .speed-control {
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 12px;
          margin: 16px 0;
          padding: 8px 0;
        }
        
        .volume-slider, .speed-slider {
          flex: 1;
          height: 3px;
          background: #e0e0e0;
          border-radius: 2px;
          outline: none;
          -webkit-appearance: none;
        }
        
        .volume-slider::-webkit-slider-thumb, .speed-slider::-webkit-slider-thumb {
          -webkit-appearance: none;
          width: 18px;
          height: 18px;
          border-radius: 50%;
          background: #34C759;
          cursor: pointer;
        }
        
        .volume-btn, .speed-btn {
          width: 32px;
          height: 32px;
          border-radius: 50%;
          border: none;
          background: #f0f0f0;
          color: #333;
          font-size: 14px;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
        }
        
        .speed-display {
          min-width: 50px;
          text-align: center;
          font-weight: 500;
          color: #333;
        }

        /* Collapsible playlist */
        .playlist-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          cursor: pointer;
          padding: 8px 0;
        }
        
        .playlist-header h3 {
          margin: 0;
          font-size: 16px;
          color: #333;
        }
        
        .toggle-icon {
          transition: transform 0.3s ease;
        }
        
        .playlist-content {
          max-height: 300px;
          overflow-y: auto;
          transition: max-height 0.3s ease;
        }
        
        .playlist-content.hidden {
          max-height: 0;
          overflow: hidden;
        }
        
        .rotate-180 {
          transform: rotate(180deg);
        }
        
        .playlist-item {
          padding: 12px 8px;
          border-bottom: 1px solid #eee;
          cursor: pointer;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        
        .playlist-item:last-child {
          border-bottom: none;
        }
        
        .playlist-item:hover {
          background-color: #f9f9f9;
        }
        
        .playlist-item.active {
          background-color: #F0F9F3;
          border-left: 3px solid #34C759;
        }
        
        .playlist-item .track-title {
          font-size: 14px;
          font-weight: 500;
          color: #333;
        }
        
        .playlist-item .track-details {
          font-size: 12px;
          color: #888;
        }
        
        .muted { 
          color: #888; 
          text-align: center;
          padding: 20px;
        }
        
        .audio-element {
          display: none;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
          .app-container {
            padding: 8px;
          }
          
          .card {
            border-radius: 12px;
            padding: 16px;
          }
        }
    </style>
    </style>
    </style>
</head>
<body>
  <div class="app-header">
    <div style="position: relative; display: flex; flex-direction: column; align-items: center; margin-bottom: 8px; gap: 8px;">
      <select id="story-selector" class="book-selector">
        <option value="">Select a story...</option>
        <option value="middlemarch">Middlemarch</option>
      </select>
      <select id="book-selector" class="book-selector" disabled>
        <option value="">Select a book...</option>
      </select>
      <div id="selectors-arrows" style="position: absolute; right: 16px; top: 50%; transform: translateY(-50%); pointer-events: none; color: #666;">
        <div style="position: absolute; left: -30px;">▼</div>
        <div style="position: absolute; left: 0;">▼</div>
      </div>
    </div>
    <div class="app-subtitle">Character-specific voices</div>
  </div>

  <div class="app-container">
    <div class="card">
      <h3 class="card-title">Now Playing</h3>
      <div class="current-info">
        <div class="book-title"><span id="current-book-title">Select a book</span></div>
        <div class="book-details">
          Book <span id="current-book">1</span>, Chapter <span id="current-chapter">1</span>
        </div>
        <div class="speaker-info">
          <span class="speaker-character" id="current-speaker">Narrator</span>
        </div>
      </div>
    </div>
    
    <div class="card">
      <h3 class="card-title">Controls</h3>
      <div class="player-controls">
        <div class="time-display">
          <span id="current-time">0:00</span> / <span id="total-time">0:00</span>
        </div>
        
        <div class="progress-container" id="progress-container">
          <div class="progress-bar"><div class="progress" id="progress"></div></div>
        </div>
        
        <div class="control-buttons">
          <button class="control-btn" id="chapter-prev-btn" title="Previous Chapter">⏮</button>
          <button class="control-btn" id="prev-btn" title="Previous Track">◀</button>
          <button class="control-btn primary" id="play-btn">
            <span id="play-icon">▶</span>
          </button>
          <button class="control-btn" id="next-btn" title="Next Track">▶</button>
          <button class="control-btn" id="chapter-next-btn" title="Next Chapter">⏭</button>
        </div>
        
        <div class="volume-control">
          <button class="volume-btn">-</button>
          <input type="range" class="volume-slider" id="volume-slider" min="0" max="1" step="0.01" value="0.7">
          <button class="volume-btn">+</button>
        </div>
        
        <div class="speed-control">
          <button class="speed-btn" id="speed-down">-</button>
          <div class="speed-display" id="speed-display">1.0x</div>
          <button class="speed-btn" id="speed-up">+</button>
        </div>
      </div>
    </div>
    
    <div class="card">
      <div class="playlist-header" id="playlist-toggle">
        <h3>Playback Queue</h3>
        <div class="toggle-icon">▼</div>
      </div>
      <div class="playlist-content" id="playlist-container">
        <div id="playlist-items" class="playlist"></div>
      </div>
    </div>
  </div>
  
  <audio class="audio-element" id="audio-player" crossorigin="anonymous"></audio>
    
    <script>
        // Audiobook Player Implementation
        class AudiobookPlayer {
            constructor() {
                this.audio = document.getElementById('audio-player');
                this.playBtn = document.getElementById('play-btn');
                this.prevBtn = document.getElementById('prev-btn');
                this.nextBtn = document.getElementById('next-btn');
                this.progressBar = document.getElementById('progress-bar');
                this.progress = document.getElementById('progress');
                this.currentTimeEl = document.getElementById('current-time');
                this.totalTimeEl = document.getElementById('total-time');
                this.volumeSlider = document.getElementById('volume-slider');
                this.currentBookEl = document.getElementById('current-book');
                this.currentChapterEl = document.getElementById('current-chapter');
                this.currentSpeakerEl = document.getElementById('current-speaker');
                this.currentBookTitleEl = document.getElementById('current-book-title');
                this.playlistItemsEl = document.getElementById('playlist-items');
                this.speedDownBtn = document.getElementById('speed-down');
                this.speedUpBtn = document.getElementById('speed-up');
                this.speedDisplay = document.getElementById('speed-display');
                this.progressContainer = document.getElementById('progress-container'); // Updated reference
                this.chapterPrevBtn = document.getElementById('chapter-prev-btn');
                this.chapterNextBtn = document.getElementById('chapter-next-btn');
                this.storySelector = document.getElementById('story-selector');
                this.bookSelector = document.getElementById('book-selector');
                
                // Define the available stories and their books
                this.stories = {
                    'middlemarch': {
                        name: 'Middlemarch',
                        books: [
                            { id: 'book1', name: 'Book 1', path: 'https://pub-4b3889db161a4e9c8a8e34ccec2cc57e.r2.dev/audio_output/book_1_multi_voice_metadata.json' },
                            { id: 'book2', name: 'Book 2', path: 'https://pub-4b3889db161a4e9c8a8e34ccec2cc57e.r2.dev/audio_output/book_2_multi_voice_metadata.json' },
                            { id: 'book3', name: 'Book 3', path: 'https://pub-4b3889db161a4e9c8a8e34ccec2cc57e.r2.dev/audio_output/book_3_multi_voice_metadata.json' },
                            { id: 'book4', name: 'Book 4', path: 'https://pub-4b3889db161a4e9c8a8e34ccec2cc57e.r2.dev/audio_output/book_4_multi_voice_metadata.json' },
                            { id: 'book5', name: 'Book 5', path: 'https://pub-4b3889db161a4e9c8a8e34ccec2cc57e.r2.dev/audio_output/book_5_multi_voice_metadata.json' },
                            { id: 'book6', name: 'Book 6', path: 'https://pub-4b3889db161a4e9c8a8e34ccec2cc57e.r2.dev/audio_output/book_6_multi_voice_metadata.json' },
                            { id: 'book7', name: 'Book 7', path: 'https://pub-4b3889db161a4e9c8a8e34ccec2cc57e.r2.dev/audio_output/book_7_multi_voice_metadata.json' },
                            { id: 'book8', name: 'Book 8', path: 'https://pub-4b3889db161a4e9c8a8e34ccec2cc57e.r2.dev/audio_output/book_8_multi_voice_metadata.json' }
                        ]
                    }
                    // To add another story, uncomment and modify this template:
                    /*
                    'another_story': {
                        name: 'Another Story Name',
                        books: [
                            { id: 'book1', name: 'Book 1', path: 'https://pub-4b3889db161a4e9c8a8e34ccec2cc57e.r2.dev/path/to/another_story_book1_metadata.json' },
                            { id: 'book2', name: 'Book 2', path: 'https://pub-4b3889db161a4e9c8a8e34ccec2cc57e.r2.dev/path/to/another_story_book2_metadata.json' }
                        ]
                    }
                    */
                };
                
                this.currentTrackIndex = -1; // Start with no track selected
                this.currentSpeed = 1.0; // Default playback speed
                this.tracks = [];
                this.audioBuffers = new Map(); // For seamless playback
                this.preloadQueue = []; // Queue for preloading
                this.isReady = false;
                this.isPlaying = false;
                
                this.init();
            }
            
            async init() {
                try {
                    // Add event listeners first
                    this.addEventListeners();
                    
                    // Initialize story selector with available stories
                    this.initStorySelector();
                    
                    // Set the story selector to Middlemarch by default
                    this.storySelector.value = 'middlemarch';
                    // Enable book selector and populate with books for Middlemarch
                    this.updateBookSelector();
                    
                    // Set the book selector to Book 1 by default
                    this.bookSelector.value = 'book1';
                    
                    // Load the metadata for the default book (Middlemarch Book 1)
                    await this.loadBook('book1');
                    
                    // Set initial volume
                    this.audio.volume = this.volumeSlider.value;
                    
                    this.isReady = true;
                    console.log('Audiobook player initialized with', this.tracks.length, 'tracks');
                } catch (error) {
                    console.error('Error initializing audiobook player:', error);
                    const currentInfoEl = document.querySelector('.current-info');
                    if (currentInfoEl) {
                        currentInfoEl.innerHTML = '<div class="muted">Error loading audiobook data. Please check if the metadata file exists.</div>';
                    } else {
                        // Fallback if the element doesn't exist
                        console.error('Could not find .current-info element to display error message');
                    }
                }
            }
            
            preloadTracks(startIndex, count) {
                // Schedule preloading asynchronously to avoid blocking
                setTimeout(() => {
                    const endIndex = Math.min(startIndex + count, this.tracks.length);
                    for (let i = startIndex; i < endIndex; i++) {
                        if (!this.audioBuffers.has(i)) {
                            // Create a temporary audio element for preloading
                            const audio = new Audio();
                            audio.preload = 'auto';
                            const audioPath = this.tracks[i].filePath;  // Already converted to CDN URL when loading metadata
                            audio.src = audioPath;
                            
                            // Store in buffer map
                            this.audioBuffers.set(i, audio);
                            
                            // Only preload the first part of the file
                            audio.load();
                        }
                    }
                }, 0);
            }
            
            addEventListeners() {
                // Play/Pause button
                this.playBtn.addEventListener('click', () => {
                    if (this.tracks.length === 0) return;
                    
                    if (this.audio.paused) {
                        // If no source is set or it's the initial state, load the first track
                        if (!this.audio.src || this.audio.src === window.location.href) {
                            this.playTrack(0);
                        } else {
                            this.audio.play();
                            this.isPlaying = true;
                            document.getElementById('play-icon').textContent = '⏸';
                        }
                    } else {
                        this.audio.pause();
                        this.isPlaying = false;
                        document.getElementById('play-icon').textContent = '▶';
                    }
                });
                
                // Next button
                this.nextBtn.addEventListener('click', () => {
                    this.nextTrack();
                });
                
                // Previous button
                this.prevBtn.addEventListener('click', () => {
                    this.prevTrack();
                });
                
                // Chapter next button
                this.chapterNextBtn.addEventListener('click', () => {
                    this.nextChapter();
                });
                
                // Chapter previous button
                this.chapterPrevBtn.addEventListener('click', () => {
                    this.prevChapter();
                });
                
                // Progress bar click
                this.progressContainer.addEventListener('click', (e) => {
                    const rect = this.progressContainer.getBoundingClientRect();
                    const pos = (e.clientX - rect.left) / rect.width;
                    this.audio.currentTime = pos * this.audio.duration;
                });
                
                // Volume control
                this.volumeSlider.addEventListener('input', () => {
                    this.audio.volume = this.volumeSlider.value;
                });
                
                // Volume buttons
                const volumeDownBtn = document.querySelector('.volume-btn:first-child');
                const volumeUpBtn = document.querySelector('.volume-btn:last-child');
                
                volumeDownBtn.addEventListener('click', () => {
                    let newVolume = Math.max(0, this.audio.volume - 0.1);
                    this.audio.volume = newVolume;
                    this.volumeSlider.value = newVolume;
                });
                
                volumeUpBtn.addEventListener('click', () => {
                    let newVolume = Math.min(1, this.audio.volume + 0.1);
                    this.audio.volume = newVolume;
                    this.volumeSlider.value = newVolume;
                });
                
                // Audio events
                this.audio.addEventListener('timeupdate', () => {
                    if (this.audio.duration) {
                        const progressPercent = (this.audio.currentTime / this.audio.duration) * 100;
                        document.getElementById('progress').style.width = `${progressPercent}%`;
                        this.currentTimeEl.textContent = this.formatTime(this.audio.currentTime);
                    }
                });
                
                this.audio.addEventListener('loadedmetadata', () => {
                    console.log('Audio metadata loaded, duration:', this.audio.duration);
                    this.totalTimeEl.textContent = this.formatTime(this.audio.duration);
                });
                
                // Handle errors in loading audio
                this.audio.addEventListener('error', (e) => {
                    console.error('Error loading audio:', e.target.error);
                    console.error('Audio src that failed:', this.audio.src);
                    alert(`Error loading audio file from CDN. Make sure the file exists at the expected CDN path.\n\nAudio URL: ${this.audio.src}`);
                });
                
                this.audio.addEventListener('ended', () => {
                    this.nextTrack();
                });
                
                this.audio.addEventListener('play', () => {
                    this.isPlaying = true;
                    document.getElementById('play-icon').textContent = '⏸';
                });
                
                this.audio.addEventListener('pause', () => {
                    this.isPlaying = false;
                    document.getElementById('play-icon').textContent = '▶';
                });
                
                // Preload next track when current track is almost finished
                this.audio.addEventListener('timeupdate', () => {
                    if (this.audio.duration) {
                        const timeRemaining = this.audio.duration - this.audio.currentTime;
                        if (timeRemaining < 10 && this.currentTrackIndex + 1 < this.tracks.length) {
                            // Preload the next track to ensure smooth transition
                            this.preloadTracks(this.currentTrackIndex + 1, 1);
                        }
                    }
                });
                
                // Speed control events
                this.speedDownBtn.addEventListener('click', () => {
                    this.changeSpeed(-0.25);
                });
                
                this.speedUpBtn.addEventListener('click', () => {
                    this.changeSpeed(0.25);
                });
                
                // Story selector change
                this.storySelector.addEventListener('change', (e) => {
                    const selectedStory = e.target.value;
                    if (selectedStory) {
                        this.updateBookSelector();
                    } else {
                        // If no story selected, disable book selector
                        this.bookSelector.disabled = true;
                        this.bookSelector.innerHTML = '<option value="">Select a book...</option>';
                    }
                });
                
                // Book selector change
                this.bookSelector.addEventListener('change', (e) => {
                    const selectedBook = e.target.value;
                    if (selectedBook) {
                        this.loadBook(selectedBook);
                    }
                });
                
                // Playlist toggle
                const playlistToggle = document.getElementById('playlist-toggle');
                const playlistContainer = document.getElementById('playlist-container');
                const toggleIcon = playlistToggle.querySelector('.toggle-icon');
                
                playlistToggle.addEventListener('click', () => {
                    playlistContainer.classList.toggle('hidden');
                    toggleIcon.classList.toggle('rotate-180');
                    
                    // Update icon based on visibility
                    if (playlistContainer.classList.contains('hidden')) {
                        toggleIcon.textContent = '▶'; // Right pointing arrow when collapsed
                    } else {
                        toggleIcon.textContent = '▼'; // Down pointing arrow when expanded
                    }
                });
                
                // Initially collapse the playlist
                playlistContainer.classList.add('hidden');
                toggleIcon.textContent = '▶';
            }
            
            async playTrack(index) {
                if (index < 0 || index >= this.tracks.length) return;
                
                this.currentTrackIndex = index;
                
                // Update track info display
                this.updateTrackInfo();
                
                // Update playlist highlighting
                this.updatePlaylist();
                
                // Update UI to indicate loading
                document.getElementById('play-icon').textContent = '⏳';
                
                const audioPath = this.tracks[index].filePath;
                
                console.log('Attempting to play audio file:', audioPath);
                console.log('Audio path:', audioPath);
                
                // Set the audio source (already converted to CDN URL when loading metadata)
                this.audio.src = audioPath;
                
                // Wait for the audio to load and play
                try {
                    // Apply current playback rate before playing
                    this.audio.playbackRate = this.currentSpeed;
                    
                    await this.audio.play();
                    this.isPlaying = true;
                    document.getElementById('play-icon').textContent = '⏸';
                } catch (error) {
                    console.error('Error playing audio:', error);
                    console.log('Failed to load audio from path:', audioPath);
                    
                    // If play fails due to user interaction requirements, try again after brief pause
                    setTimeout(async () => {
                        try {
                            // Apply current playback rate before playing
                            this.audio.playbackRate = this.currentSpeed;
                            
                            await this.audio.play();
                            this.isPlaying = true;
                            document.getElementById('play-icon').textContent = '⏸';
                        } catch (err) {
                            console.error('Unable to play audio after retry:', err);
                            document.getElementById('play-icon').textContent = '▶';
                            
                            // Show error message to user
                            alert(`Could not play audio file: ${audioPath}\nMake sure the file exists and you're serving the site via a web server.\nActual path: ${audioPath}`);
                        }
                    }, 100);
                }
                
                // Preload next few tracks in background
                this.preloadTracks(index + 1, 3);
            }
            
            play() {
                if (this.isReady && this.tracks.length > 0) {
                    // If no track has been selected yet, start with the first track
                    if (this.currentTrackIndex < 0 || this.currentTrackIndex >= this.tracks.length) {
                        this.currentTrackIndex = 0;
                        this.playTrack(0);
                    } else {
                        this.audio.play();
                        this.isPlaying = true;
                        document.getElementById('play-icon').textContent = '⏸';
                    }
                }
            }
            
            pause() {
                this.audio.pause();
                this.isPlaying = false;
                document.getElementById('play-icon').textContent = '▶';
            }
            
            changeSpeed(delta) {
                // Calculate new speed (min 0.5x, max 2.0x)
                let newSpeed = this.currentSpeed + delta;
                
                // Limit speed between 0.5x and 2.0x
                newSpeed = Math.max(0.5, Math.min(2.0, newSpeed));
                
                // Round to 2 decimal places to avoid floating point issues
                newSpeed = Math.round(newSpeed * 100) / 100;
                
                this.currentSpeed = newSpeed;
                
                // Apply the speed to the audio element
                this.audio.playbackRate = this.currentSpeed;
                
                // Update the display
                this.speedDisplay.textContent = `${this.currentSpeed}x`;
            }
            
            nextChapter() {
                if (this.currentTrackIndex < 0 || this.currentTrackIndex >= this.tracks.length) return;
                
                const currentChapter = this.tracks[this.currentTrackIndex].chapter;
                const currentBook = this.tracks[this.currentTrackIndex].book;
                
                // Find the next chapter in the same book
                for (let i = this.currentTrackIndex + 1; i < this.tracks.length; i++) {
                    if (this.tracks[i].book === currentBook && this.tracks[i].chapter > currentChapter) {
                        // Found the next chapter, now find the first track in that chapter
                        for (let j = i; j < this.tracks.length; j++) {
                            if (this.tracks[j].chapter === this.tracks[i].chapter && this.tracks[j].book === currentBook) {
                                this.playTrack(j);
                                break;
                            }
                        }
                        return;
                    }
                    
                    // If we've moved to a new book, find the first chapter in that book
                    if (this.tracks[i].book > currentBook) {
                        for (let j = i; j < this.tracks.length; j++) {
                            if (this.tracks[j].book === this.tracks[i].book && this.tracks[j].chapter === 1) {
                                this.playTrack(j);
                                break;
                            }
                        }
                        return;
                    }
                }
            }
            
            prevChapter() {
                if (this.currentTrackIndex < 0 || this.currentTrackIndex >= this.tracks.length) return;
                
                const currentChapter = this.tracks[this.currentTrackIndex].chapter;
                const currentBook = this.tracks[this.currentTrackIndex].book;
                
                // Find the previous chapter in the same book or previous book
                for (let i = this.currentTrackIndex - 1; i >= 0; i--) {
                    // If we're still in the same book but different chapter
                    if (this.tracks[i].book === currentBook && this.tracks[i].chapter < currentChapter) {
                        // Found the previous chapter, now find the first track in that chapter
                        for (let j = i; j >= 0; j--) {
                            if (this.tracks[j].chapter === this.tracks[i].chapter && this.tracks[j].book === currentBook) {
                                // Continue backward until we find the first occurrence of this chapter
                                if (j === 0 || this.tracks[j-1].chapter !== this.tracks[i].chapter) {
                                    this.playTrack(j);
                                    return;
                                }
                            }
                        }
                        return;
                    }
                    
                    // If we've moved to a previous book, find the last chapter in that book
                    if (this.tracks[i].book < currentBook) {
                        // Find the highest chapter in the previous book
                        let highestChapter = 0;
                        for (let k = 0; k <= i; k++) {
                            if (this.tracks[k].book === this.tracks[i].book) {
                                highestChapter = Math.max(highestChapter, this.tracks[k].chapter);
                            }
                        }
                        
                        // Find the first track of the highest chapter in the previous book
                        for (let j = i; j >= 0; j--) {
                            if (this.tracks[j].book === this.tracks[i].book && this.tracks[j].chapter === highestChapter) {
                                if (j === 0 || this.tracks[j-1].chapter !== highestChapter) {
                                    this.playTrack(j);
                                    return;
                                }
                            }
                        }
                        return;
                    }
                }
            }
            
            pause() {
                this.audio.pause();
            }
            
            nextTrack() {
                if (this.currentTrackIndex < this.tracks.length - 1) {
                    this.playTrack(this.currentTrackIndex + 1);
                }
            }
            
            prevTrack() {
                if (this.currentTrackIndex > 0) {
                    this.playTrack(this.currentTrackIndex - 1);
                }
            }
            
            updateTrackInfo() {
                const track = this.tracks[this.currentTrackIndex];
                if (track) {
                    this.currentBookEl.textContent = track.book;
                    this.currentChapterEl.textContent = track.chapter;
                    this.currentSpeakerEl.textContent = track.character;
                    
                    // Update book title based on the current book selection
                    const selectedBookOption = this.bookSelector.options[this.bookSelector.selectedIndex];
                    const selectedStoryOption = this.storySelector.options[this.storySelector.selectedIndex];
                    
                    if (selectedBookOption && selectedBookOption.value) {
                        const bookName = selectedBookOption.text;
                        this.currentBookTitleEl.textContent = bookName;
                    } else if (selectedStoryOption && selectedStoryOption.value) {
                        const storyName = selectedStoryOption.text;
                        this.currentBookTitleEl.textContent = storyName;
                    } else {
                        this.currentBookTitleEl.textContent = `Select a book`;
                    }
                }
            }
            
            initStorySelector() {
                // Clear existing options except the first one
                this.storySelector.innerHTML = '<option value="">Select a story...</option>';
                
                // Add options for each story
                for (const [storyId, storyInfo] of Object.entries(this.stories)) {
                    const option = document.createElement('option');
                    option.value = storyId;
                    option.textContent = storyInfo.name;
                    this.storySelector.appendChild(option);
                }
            }
            
            updateBookSelector() {
                const selectedStory = this.storySelector.value;
                
                if (selectedStory && this.stories[selectedStory]) {
                    // Enable book selector
                    this.bookSelector.disabled = false;
                    
                    // Clear existing options except the first one
                    this.bookSelector.innerHTML = '<option value="">Select a book...</option>';
                    
                    // Add options for each book in the selected story
                    const books = this.stories[selectedStory].books;
                    books.forEach(book => {
                        const option = document.createElement('option');
                        option.value = book.id;
                        option.textContent = book.name;
                        this.bookSelector.appendChild(option);
                    });
                } else {
                    // Disable book selector if no story is selected
                    this.bookSelector.disabled = true;
                    this.bookSelector.innerHTML = '<option value="">Select a book...</option>';
                }
            }
            
            updatePlaylist() {
                this.playlistItemsEl.innerHTML = '';
                
                this.tracks.forEach((track, index) => {
                    const item = document.createElement('div');
                    item.className = `playlist-item ${index === this.currentTrackIndex ? 'active' : ''}`;
                    item.innerHTML = `
                        <div class="track-title">${track.character}: ${track.title}</div>
                        <div class="track-details">Book ${track.book}, Chapter ${track.chapter} • ${track.contentType}</div>
                    `;
                    item.addEventListener('click', () => {
                        this.playTrack(index);
                    });
                    this.playlistItemsEl.appendChild(item);
                });
                
                // Scroll to active item
                const activeItem = this.playlistItemsEl.querySelector('.active');
                if (activeItem) {
                    activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
            
            async loadBook(bookId) {
                try {
                    // Get the selected story
                    const selectedStory = this.storySelector.value;
                    
                    if (!selectedStory || !this.stories[selectedStory]) {
                        console.error('No story selected or story not found');
                        return;
                    }
                    
                    // Find the selected book in the story's books
                    const bookInfo = this.stories[selectedStory].books.find(book => book.id === bookId);
                    
                    if (!bookInfo) {
                        console.error('Book not found:', bookId);
                        return;
                    }
                    
                    // Fetch the metadata file for the selected book
                    const response = await fetch(bookInfo.path);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const metadata = await response.json();
                    
                    // Extract tracks from metadata and convert local file paths to CDN paths
                    // Using Cloudflare R2 for audio files
                    this.tracks = metadata.audio_files.map((file, index) => {
                        const cdnPath = file.file_path.startsWith('audio_output/') 
                            ? `https://pub-4b3889db161a4e9c8a8e34ccec2cc57e.r2.dev/${file.file_path}`
                            : file.file_path;
                        console.log('Converted audio path:', file.file_path, '->', cdnPath);
                        return {
                            id: index,
                            title: file.text.substring(0, 60) + (file.text.length > 60 ? '...' : ''),
                            character: file.character_name,
                            characterId: file.character_id,
                            book: file.book_number,
                            chapter: file.chapter_number,
                            filePath: cdnPath,
                            fullText: file.text,
                            contentType: file.content_type
                        };
                    });
                    
                    // Update the UI with tracks
                    this.updatePlaylist();
                    
                    // Reset player state
                    this.currentTrackIndex = -1;
                    this.audio.pause();
                    
                    // Preload first few tracks and prepare the first track
                    if (this.tracks.length > 0) {
                        this.currentTrackIndex = 0;
                        this.audio.src = this.tracks[0].filePath;  // Already converted to CDN URL when loading metadata
                        console.log('Set initial audio source to:', this.audio.src);
                        
                        // Update display to show first track info
                        this.updateTrackInfo();
                        this.updatePlaylist();
                    } else {
                        console.error('No tracks found in metadata file');
                    }
                    
                    this.isReady = true;
                    console.log(`Book ${bookId} loaded with`, this.tracks.length, 'tracks');
                    
                } catch (error) {
                    console.error('Error loading book:', error);
                    const currentInfoEl = document.querySelector('.current-info');
                    if (currentInfoEl) {
                        currentInfoEl.innerHTML = '<div class="muted">Error loading book. Please check if the metadata file exists.</div>';
                    }
                }
            }
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
            }
        }
        
        // Initialize the player when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new AudiobookPlayer();
        });
    </script>
</body>
</html>